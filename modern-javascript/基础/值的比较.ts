// 字符串的比较
// 首先比较两个字符串的首位字符大小。
// 如果一方字符较大（或较小），则该字符串大于（或小于）另一个字符串。算法结束。
// 否则，如果两个字符串的首位字符相等，则继续取出两个字符串各自的后一位字符进行比较。
// 重复上述步骤进行比较，直到比较完成某字符串的所有字符为止。
// 如果两个字符串的字符同时用完，那么则判定它们相等，否则未结束（还有未比较的字符）的字符串更大。
"Z" > "A" // true
"Glow" > "Glee" // true
"Bee" > "Be" // true
// 字符串比较对字母大小写是敏感的。大写的 "A" 并不等于小写的 "a"。实际上小写的 "a" 更大。因为在 JavaScript 使用的内部编码表中（Unicode），小写字母的字符索引值更大

// null与undefined进行比较
null === undefined // false
null == undefined // true
// 当使用数学式或其他比较方法 < > <= >= 时, null/undefined 会被转化为数字：null 被转化为 0，undefined 被转化为 NaN

// null vs 0
null > 0 // (1) false
null == 0 // (2) false
null >= 0 // (3) true
// 为什么会出现这种反常结果，这是因为相等性检查 == 和普通比较符 > < >= <= 的代码逻辑是相互独立的。
// 进行值的比较时，null 会被转化为数字，因此它被转化为了 0。这就是为什么（3）中 null >= 0 返回值是 true，（1）中 null > 0 返回值是 false。
// 另一方面，undefined 和 null 在相等性检查 == 中不会进行任何的类型转换，它们有自己独立的比较规则，所以除了它们之间互等外，不会等于任何其他的值。这就解释了为什么（2）中 null == 0 会返回 false。

// undefined 不应该被与其他值进行比较
undefined > 0 // false (1)
undefined < 0 // false (2)
undefined == 0 // false (3)
// (1) 和 (2) 都返回 false 是因为 undefined 在比较中被转换为了 NaN，而 NaN 是一个特殊的数值型值，它与任何值进行比较都会返回 false。
// (3) 返回 false 是因为这是一个相等性检查，而 undefined 只与 null 相等，不会与其他值相等。

// 总结
// 比较运算符始终返回布尔值。
// 字符串的比较，会按照“词典”顺序逐字符地比较大小。
// 当对不同类型的值进行比较时，它们会先被转化为数字（不包括严格相等检查）再进行比较。
// 在非严格相等 == 下，null 和 undefined 相等且各自不等于任何其他的值。
// 在使用 > 或 < 进行比较时，需要注意变量可能为 null/undefined 的情况。比较好的方法是单独检查变量是否等于 null/undefined。
